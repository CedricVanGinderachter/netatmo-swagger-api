import request = require('request');
import promise = require('bluebird');
import http = require('http');

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class AccessToken {
    accessToken: string;
    refreshToken: string;
    expireIn: number;
    expiresIn: number;
    scope: Array<string>;
}

export class NAResponse {
    status: string;
    timeExec: number;
    timeServer: number;
}

export class NAOkResponse extends NAResponse {
    body: string;
}

export class NAUserResponse extends NAResponse {
    body: NAUserBody;
}

export class NADeviceListResponse extends NAResponse {
    body: NADeviceListBody;
}

export class NAMeasureResponse extends NAResponse {
    body: Array<NAMeasureBodyElem>;
}

export class NAThermStateResponse extends NAResponse {
    body: NAThermStateBody;
}

export class NANewScheduleResponse extends NAResponse {
    body: NANewScheduleBody;
}

export class NAPartnerDevicesResponse extends NAResponse {
    body: Array<string>;
}

export class NAUserBody {
    id: string;
    /**
    * Contains administrative information related to the user
    */
    administrative: NAUserAdministrative;
    dateCreation: NADate;
    /**
    * An array of string containing the ids of the devices owned by the user
    */
    devices: Array<string>;
    /**
    * An array of string containing the ids of the devices on which the user has a \"guest\" access
    */
    friendDevices: Array<string>;
    mail: string;
    timelineNotRead: number;
    timelineSize: number;
}

export class NADeviceListBody {
    devices: Array<NADevice>;
    modules: Array<NAModule>;
}

export class NAMeasureBodyElem {
    begTime: number;
    stepTime: number;
    value: Array<Array<number>>;
}

export class NAThermStateBody {
    setpoint: NASetpoint;
    setpointOrder: NASetpoint;
    thermProgram: NAThermProgram;
    thermProgramBackup: Array<NAThermProgram>;
    thermProgramOrder: NAThermProgram;
    thermOrientation: number;
    thermRelayCmd: number;
    batteryVp: number;
    rfStatus: number;
    plugConnectedBoiler: boolean;
    udpConn: boolean;
    lastThermSeen: number;
    lastPlugSeen: number;
    wifiStatus: number;
    measured: NAThermMeasure;
}

export class NANewScheduleBody {
    /**
    * Id of the schedule. It can be use with the method \"switchschedule\"
    */
    scheduleId: string;
}

export class NAUserAdministrative {
    /**
    * user country
    */
    country: string;
    /**
    * user locale
    */
    lang: string;
    /**
    * user regional preferences (used for displaying date)
    */
    regLocale: string;
    /**
    * 0 -> metric system, 1 -> imperial system
    */
    unit: string;
    /**
    * 0 -> kph, 1 -> mph, 2 -> ms, 3 -> beaufort, 4 -> knot
    */
    windunit: string;
    /**
    * 0 -> mbar, 1 -> inHg, 2 -> mmHg
    */
    pressureunit: string;
    /**
    * algorithm used to compute feel like temperature, 0 -> humidex, 1 -> heat-index
    */
    feelLikeAlgo: string;
}

export class NADate {
    sec: number;
    usec: number;
}

export class NADevice {
    id: string;
    behavior: number;
    cipherId: string;
    dateSetup: NADate;
    firmware: number;
    hwVersion: number;
    heatingSystem: NAHeatingSystem;
    houseModel: NAHouseModel;
    ip: string;
    lastFwUpdate: number;
    lastRadioStore: number;
    lastStatusStore: number;
    lastUpgrade: number;
    moduleName: string;
    /**
    * It lists which modules are linked with this device
    */
    modules: Array<string>;
    place: NAPlace;
    setpoint: any;
    setpointDefaultDuration: number;
    setpointOrder: { [key: string]: Array<NAObject>; };
    publicExtData: boolean;
    stationName: string;
    thermProgram: { [key: string]: NAThermProgram; };
    thermProgramBackup: { [key: string]: Array<NAThermProgram>; };
    thermProgramOrder: { [key: string]: Array<NAObject>; };
    /**
    * Included in every device or module. It defines the type of the device/module. Its values are among :\nNAMain : for the base station\nNAModule1 : for the outdoor module\nNAModule4 : for the additionnal indoor module\nNAModule3 : for the rain gauge module\nNAPlug : for the thermostat relay/plug\nNATherm1 : for the thermostat module
    */
    type: string;
    userOwner: Array<string>;
    udpConn: boolean;
    /**
    * It contains the current wifi status. The different thresholds to take into account are\nRSSI_THRESHOLD_0 = 86 bad signal\nRSSI_THRESHOLD_1 = 71 middle quality signal\nRSSI_THRESHOLD_2 = 56 good signal
    */
    wifiStatus: number;
    newFeatureAvail: boolean;
    firstPidAvail: boolean;
    dataType: Array<string>;
}

export class NAModule {
    id: string;
    dateSetup: NADate;
    firmware: number;
    /**
    * Included in every device or module. It defines the type of the device/module. Its values are among :\nNAMain : for the base station\nNAModule1 : for the outdoor module\nNAModule4 : for the additionnal indoor module\nNAModule3 : for the rain gauge module\nNAPlug : for the thermostat relay/plug\nNATherm1 : for the thermostat module
    */
    type: string;
    moduleName: string;
    mainDevice: string;
    lastMessage: number;
    lastSeen: number;
    publicExtData: boolean;
    /**
    * \"It contains the current radio status. The different thresholds to take into account are :\" |\nRADIO_THRESHOLD_SIGNAL_LOW = 90 \nRADIO_THRESHOLD_SIGNAL_MEDIUM = 80\nRADIO_THRESHOLD_SIGNAL_HIGH = 70\nRADIO_THRESHOLD_SIGNAL_FULL = 60
    */
    rfStatus: number;
    /**
    * It contains the current battery status. The threshold depends on the kind of module, below is the list of the different threshold to take into account according the module type.\n\"Indoor module Battery range: 6000 ... 4200\" |\nINDOOR_BATTERY_LEVEL_FULL = 5640\nINDOOR_BATTERY_LEVEL_HIGH = 5280\nINDOOR_BATTERY_LEVEL_MEDIUM = 4920\nINDOOR_BATTERY_LEVEL_LOW = 4560\n\"Below 4560: very low\" |\n  \n\"Raingauge and outdoor module Battery range: 6000 ... 3600\" |\nBATTERY_LEVEL_FULL = 5500\nBATTERY_LEVEL_HIGH = 5000\nBATTERY_LEVEL_MEDIUM = 4500\nBATTERY_LEVEL_LOW = 4000\n\"Below 4000: very low\" |\n  \n\"Thermostat Battery range: 4500 ... 3000\" |\nTHERMOSTAT_BATTERY_LEVEL_FULL = 4100\nTHERMOSTAT_BATTERY_LEVEL_HIGH = 3600\nTHERMOSTAT_BATTERY_LEVEL_MEDIUM = 3300\nTHERMOSTAT_BATTERY_LEVEL_LOW = 3000\n\"Below 3000: very low\"
    */
    batteryVp: number;
    thermOrientation: number;
    thermRelayCmd: number;
    /**
    * It contains all the measurements that can be displayed on the dashboard
    */
    dashboardData: NADashboardData;
    dataType: Array<string>;
}

export class NAHouseModel {
    algoType: string;
    ca: NAHouseModelCa;
    extTemps: { [key: string]: number; };
    firstAnticipateAvail: boolean;
    firstPidAvail: boolean;
    gefs: NAStation;
    inUse: string;
    lastComputeTry: NADate;
    linkStation: NALinkStation;
    pidAlgo: NAPidAlgo;
    station: NAStation;
    preferedAlgoType: string;
    simpleAlgo: NASimpleAlgo;
    time: NADate;
    stationFirsttimeAnticipate: boolean;
    timeAlgoChanged: number;
    timePidComputed: number;
}

export class NAHouseModelCa {
    te: number;
    ti: number;
    so: string;
}

export class NAStation {
    lagDown: number;
    lagUp: number;
    offOvershoot: number;
    onOvershoot: number;
    pk: number;
    tau: number;
}

export class NALinkStation {
    mac: string;
    ext: string;
    temperature: number;
}

export class NAPidAlgo {
    gain: number;
    period: number;
    td: number;
    ti: number;
}

export class NAPlace {
    city: string;
    altitude: number;
    country: string;
    fromIp: boolean;
    improveLocProposed: boolean;
    location: Array<number>;
    timezone: string;
    trustLocation: boolean;
}

export class NASetpoint {
    setpointTemp: number;
    setpointEndtime: number;
    setpointMode: string;
}

export class NAThermProgram {
    programId: string;
    name: string;
    zones: Array<NAZone>;
    timetable: Array<NATimeTableItem>;
    selected: boolean;
}

export class NAZone {
    id: number;
    type: number;
    name: string;
    temp: number;
}

export class NATimeTableItem {
    id: number;
    mOffset: number;
}

export class NAHeatingSystem {
    heatingEnergy: string;
    heatingSystemWindowSeen: boolean;
}

export class NASimpleAlgo {
    highDeadband: number;
}

export class NADashboardData {
    timeUtc: number;
    deviceId: number;
    boilerOn: number;
    boilerOff: number;
    /**
    * Last temperature measure @ time_utc (in Â°C)
    */
    temperature: number;
    /**
    * Timestamp when max temperature was measured
    */
    dateMaxTemp: number;
    /**
    * Timestamp when min temperature was measured
    */
    dateMinTemp: number;
    /**
    * Max temperature of the day (measured @ date_max_temp)
    */
    minTemp: number;
    /**
    * Min temperature of the day (measured @ date_min_temp)
    */
    maxTemp: number;
    /**
    * Real measured pressure @ time_utc (in mb)
    */
    absolutePressure: number;
    /**
    * Last Co2 measured @ time_utc (in ppm)
    */
    cO2: number;
    /**
    * Last humidity measured @ time_utc (in %)
    */
    humidity: number;
    /**
    * Last noise measured @ time_utc (in db)
    */
    noise: number;
    /**
    * Last Sea level pressure measured @ time_utc (in mb)
    */
    pressure: number;
    /**
    * Last rain measured (in mm)
    */
    rain: number;
    /**
    * Amount of rain in last hour
    */
    sumRain1: number;
    /**
    * Amount of rain today
    */
    sumRain24: number;
}

export class NAThermMeasure {
    time: number;
    temperature: number;
    setpointTemp: number;
}

export class NAObject {
    $Id: string;
}


interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

class OAuth implements Authentication {
    applyToRequest(requestOptions: request.Options): void {
        // TODO: support oauth
    }
}

class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export class StationApi {
    private basePath = 'https://api.netatmo.net/';
    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public devicelist (accessToken: string, appType?: string, deviceId?: string, getFavorites?: boolean) : Promise<{ response: http.ClientResponse; body: NADeviceListResponse;  }> {
        var path = this.url + this.basePath + '/api/devicelist';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling devicelist');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (appType !== undefined) {
            queryParameters['app_type'] = appType;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (getFavorites !== undefined) {
            queryParameters['get_favorites'] = getFavorites;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NADeviceListResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public getmeasure (accessToken: string, deviceId: string, scale: string, type: Array<string>, moduleId?: string, dateBegin?: number, dateEnd?: number, limit?: number, optimize?: boolean, realTime?: boolean) : Promise<{ response: http.ClientResponse; body: NAMeasureResponse;  }> {
        var path = this.url + this.basePath + '/api/getmeasure';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling getmeasure');
        }

        // verify required parameter 'deviceId' is set
        if (!deviceId) {
            throw new Error('Missing required parameter deviceId when calling getmeasure');
        }

        // verify required parameter 'scale' is set
        if (!scale) {
            throw new Error('Missing required parameter scale when calling getmeasure');
        }

        // verify required parameter 'type' is set
        if (!type) {
            throw new Error('Missing required parameter type when calling getmeasure');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (moduleId !== undefined) {
            queryParameters['module_id'] = moduleId;
        }

        if (scale !== undefined) {
            queryParameters['scale'] = scale;
        }

        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        if (dateBegin !== undefined) {
            queryParameters['date_begin'] = dateBegin;
        }

        if (dateEnd !== undefined) {
            queryParameters['date_end'] = dateEnd;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (optimize !== undefined) {
            queryParameters['optimize'] = optimize;
        }

        if (realTime !== undefined) {
            queryParameters['real_time'] = realTime;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NAMeasureResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public getuser (accessToken: string) : Promise<{ response: http.ClientResponse; body: NAUserResponse;  }> {
        var path = this.url + this.basePath + '/api/getuser';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling getuser');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NAUserResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class OauthApi {
    private basePath = 'https://api.netatmo.net/';
    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public getToken (grantType: string, clientId: string, clientSecret: string, scope?: string, username?: string, password?: string, code?: string, redirectUri?: string, refreshToken?: string) : Promise<{ response: http.ClientResponse; body: AccessToken;  }> {
        var path = this.url + this.basePath + '/oauth2/token';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'grantType' is set
        if (!grantType) {
            throw new Error('Missing required parameter grantType when calling getToken');
        }

        // verify required parameter 'clientId' is set
        if (!clientId) {
            throw new Error('Missing required parameter clientId when calling getToken');
        }

        // verify required parameter 'clientSecret' is set
        if (!clientSecret) {
            throw new Error('Missing required parameter clientSecret when calling getToken');
        }

        var useFormData = false;

        if (grantType !== undefined) {
            formParams['grant_type'] = grantType;
        }

        if (clientId !== undefined) {
            formParams['client_id'] = clientId;
        }

        if (clientSecret !== undefined) {
            formParams['client_secret'] = clientSecret;
        }

        if (scope !== undefined) {
            formParams['scope'] = scope;
        }

        if (username !== undefined) {
            formParams['username'] = username;
        }

        if (password !== undefined) {
            formParams['password'] = password;
        }

        if (code !== undefined) {
            formParams['code'] = code;
        }

        if (redirectUri !== undefined) {
            formParams['redirect_uri'] = redirectUri;
        }

        if (refreshToken !== undefined) {
            formParams['refresh_token'] = refreshToken;
        }

        var deferred = promise.defer<{ response: http.ClientResponse; body: AccessToken;  }>();

        var requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class ThermostatApi {
    private basePath = 'https://api.netatmo.net/';
    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public createnewschedule (accessToken: string, deviceId: string, moduleId: string, thermProgram: NAThermProgram) : Promise<{ response: http.ClientResponse; body: NANewScheduleResponse;  }> {
        var path = this.url + this.basePath + '/api/createnewschedule';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling createnewschedule');
        }

        // verify required parameter 'deviceId' is set
        if (!deviceId) {
            throw new Error('Missing required parameter deviceId when calling createnewschedule');
        }

        // verify required parameter 'moduleId' is set
        if (!moduleId) {
            throw new Error('Missing required parameter moduleId when calling createnewschedule');
        }

        // verify required parameter 'thermProgram' is set
        if (!thermProgram) {
            throw new Error('Missing required parameter thermProgram when calling createnewschedule');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (moduleId !== undefined) {
            queryParameters['module_id'] = moduleId;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NANewScheduleResponse;  }>();

        var requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: thermProgram,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public devicelist (accessToken: string, appType?: string, deviceId?: string, getFavorites?: boolean) : Promise<{ response: http.ClientResponse; body: NADeviceListResponse;  }> {
        var path = this.url + this.basePath + '/api/devicelist';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling devicelist');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (appType !== undefined) {
            queryParameters['app_type'] = appType;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (getFavorites !== undefined) {
            queryParameters['get_favorites'] = getFavorites;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NADeviceListResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public getmeasure (accessToken: string, deviceId: string, scale: string, type: Array<string>, moduleId?: string, dateBegin?: number, dateEnd?: number, limit?: number, optimize?: boolean, realTime?: boolean) : Promise<{ response: http.ClientResponse; body: NAMeasureResponse;  }> {
        var path = this.url + this.basePath + '/api/getmeasure';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling getmeasure');
        }

        // verify required parameter 'deviceId' is set
        if (!deviceId) {
            throw new Error('Missing required parameter deviceId when calling getmeasure');
        }

        // verify required parameter 'scale' is set
        if (!scale) {
            throw new Error('Missing required parameter scale when calling getmeasure');
        }

        // verify required parameter 'type' is set
        if (!type) {
            throw new Error('Missing required parameter type when calling getmeasure');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (moduleId !== undefined) {
            queryParameters['module_id'] = moduleId;
        }

        if (scale !== undefined) {
            queryParameters['scale'] = scale;
        }

        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        if (dateBegin !== undefined) {
            queryParameters['date_begin'] = dateBegin;
        }

        if (dateEnd !== undefined) {
            queryParameters['date_end'] = dateEnd;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (optimize !== undefined) {
            queryParameters['optimize'] = optimize;
        }

        if (realTime !== undefined) {
            queryParameters['real_time'] = realTime;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NAMeasureResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public getthermstate (accessToken: string, deviceId: string, moduleId: string) : Promise<{ response: http.ClientResponse; body: NAThermStateResponse;  }> {
        var path = this.url + this.basePath + '/api/getthermstate';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling getthermstate');
        }

        // verify required parameter 'deviceId' is set
        if (!deviceId) {
            throw new Error('Missing required parameter deviceId when calling getthermstate');
        }

        // verify required parameter 'moduleId' is set
        if (!moduleId) {
            throw new Error('Missing required parameter moduleId when calling getthermstate');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (moduleId !== undefined) {
            queryParameters['module_id'] = moduleId;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NAThermStateResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public getuser (accessToken: string) : Promise<{ response: http.ClientResponse; body: NAUserResponse;  }> {
        var path = this.url + this.basePath + '/api/getuser';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling getuser');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NAUserResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public setthermpoint (accessToken: string, deviceId: string, moduleId: string, setpointMode: string, setpointEndtime?: number, setpointTemp?: number) : Promise<{ response: http.ClientResponse; body: NAOkResponse;  }> {
        var path = this.url + this.basePath + '/api/setthermpoint';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling setthermpoint');
        }

        // verify required parameter 'deviceId' is set
        if (!deviceId) {
            throw new Error('Missing required parameter deviceId when calling setthermpoint');
        }

        // verify required parameter 'moduleId' is set
        if (!moduleId) {
            throw new Error('Missing required parameter moduleId when calling setthermpoint');
        }

        // verify required parameter 'setpointMode' is set
        if (!setpointMode) {
            throw new Error('Missing required parameter setpointMode when calling setthermpoint');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (moduleId !== undefined) {
            queryParameters['module_id'] = moduleId;
        }

        if (setpointMode !== undefined) {
            queryParameters['setpoint_mode'] = setpointMode;
        }

        if (setpointEndtime !== undefined) {
            queryParameters['setpoint_endtime'] = setpointEndtime;
        }

        if (setpointTemp !== undefined) {
            queryParameters['setpoint_temp'] = setpointTemp;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NAOkResponse;  }>();

        var requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public switchschedule (accessToken: string, deviceId: string, moduleId: string, scheduleId: string) : Promise<{ response: http.ClientResponse; body: NAOkResponse;  }> {
        var path = this.url + this.basePath + '/api/switchschedule';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling switchschedule');
        }

        // verify required parameter 'deviceId' is set
        if (!deviceId) {
            throw new Error('Missing required parameter deviceId when calling switchschedule');
        }

        // verify required parameter 'moduleId' is set
        if (!moduleId) {
            throw new Error('Missing required parameter moduleId when calling switchschedule');
        }

        // verify required parameter 'scheduleId' is set
        if (!scheduleId) {
            throw new Error('Missing required parameter scheduleId when calling switchschedule');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (moduleId !== undefined) {
            queryParameters['module_id'] = moduleId;
        }

        if (scheduleId !== undefined) {
            queryParameters['schedule_id'] = scheduleId;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NAOkResponse;  }>();

        var requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public syncschedule (accessToken: string, deviceId: string, moduleId: string, thermProgram: NAThermProgram) : Promise<{ response: http.ClientResponse; body: NAOkResponse;  }> {
        var path = this.url + this.basePath + '/api/syncschedule';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling syncschedule');
        }

        // verify required parameter 'deviceId' is set
        if (!deviceId) {
            throw new Error('Missing required parameter deviceId when calling syncschedule');
        }

        // verify required parameter 'moduleId' is set
        if (!moduleId) {
            throw new Error('Missing required parameter moduleId when calling syncschedule');
        }

        // verify required parameter 'thermProgram' is set
        if (!thermProgram) {
            throw new Error('Missing required parameter thermProgram when calling syncschedule');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (moduleId !== undefined) {
            queryParameters['module_id'] = moduleId;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NAOkResponse;  }>();

        var requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: thermProgram,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class WelcomeApi {
    private basePath = 'https://api.netatmo.net/';
    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public devicelist (accessToken: string, appType?: string, deviceId?: string, getFavorites?: boolean) : Promise<{ response: http.ClientResponse; body: NADeviceListResponse;  }> {
        var path = this.url + this.basePath + '/api/devicelist';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling devicelist');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (appType !== undefined) {
            queryParameters['app_type'] = appType;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (getFavorites !== undefined) {
            queryParameters['get_favorites'] = getFavorites;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NADeviceListResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public getmeasure (accessToken: string, deviceId: string, scale: string, type: Array<string>, moduleId?: string, dateBegin?: number, dateEnd?: number, limit?: number, optimize?: boolean, realTime?: boolean) : Promise<{ response: http.ClientResponse; body: NAMeasureResponse;  }> {
        var path = this.url + this.basePath + '/api/getmeasure';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling getmeasure');
        }

        // verify required parameter 'deviceId' is set
        if (!deviceId) {
            throw new Error('Missing required parameter deviceId when calling getmeasure');
        }

        // verify required parameter 'scale' is set
        if (!scale) {
            throw new Error('Missing required parameter scale when calling getmeasure');
        }

        // verify required parameter 'type' is set
        if (!type) {
            throw new Error('Missing required parameter type when calling getmeasure');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (moduleId !== undefined) {
            queryParameters['module_id'] = moduleId;
        }

        if (scale !== undefined) {
            queryParameters['scale'] = scale;
        }

        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        if (dateBegin !== undefined) {
            queryParameters['date_begin'] = dateBegin;
        }

        if (dateEnd !== undefined) {
            queryParameters['date_end'] = dateEnd;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (optimize !== undefined) {
            queryParameters['optimize'] = optimize;
        }

        if (realTime !== undefined) {
            queryParameters['real_time'] = realTime;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NAMeasureResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public getuser (accessToken: string) : Promise<{ response: http.ClientResponse; body: NAUserResponse;  }> {
        var path = this.url + this.basePath + '/api/getuser';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling getuser');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NAUserResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class PublicApi {
    private basePath = 'https://api.netatmo.net/';
    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public getmeasure (accessToken: string, deviceId: string, scale: string, type: Array<string>, moduleId?: string, dateBegin?: number, dateEnd?: number, limit?: number, optimize?: boolean, realTime?: boolean) : Promise<{ response: http.ClientResponse; body: NAMeasureResponse;  }> {
        var path = this.url + this.basePath + '/api/getmeasure';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling getmeasure');
        }

        // verify required parameter 'deviceId' is set
        if (!deviceId) {
            throw new Error('Missing required parameter deviceId when calling getmeasure');
        }

        // verify required parameter 'scale' is set
        if (!scale) {
            throw new Error('Missing required parameter scale when calling getmeasure');
        }

        // verify required parameter 'type' is set
        if (!type) {
            throw new Error('Missing required parameter type when calling getmeasure');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (moduleId !== undefined) {
            queryParameters['module_id'] = moduleId;
        }

        if (scale !== undefined) {
            queryParameters['scale'] = scale;
        }

        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        if (dateBegin !== undefined) {
            queryParameters['date_begin'] = dateBegin;
        }

        if (dateEnd !== undefined) {
            queryParameters['date_end'] = dateEnd;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (optimize !== undefined) {
            queryParameters['optimize'] = optimize;
        }

        if (realTime !== undefined) {
            queryParameters['real_time'] = realTime;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NAMeasureResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class PartnerApi {
    private basePath = 'https://api.netatmo.net/';
    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public devicelist (accessToken: string, appType?: string, deviceId?: string, getFavorites?: boolean) : Promise<{ response: http.ClientResponse; body: NADeviceListResponse;  }> {
        var path = this.url + this.basePath + '/api/devicelist';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling devicelist');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (appType !== undefined) {
            queryParameters['app_type'] = appType;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (getFavorites !== undefined) {
            queryParameters['get_favorites'] = getFavorites;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NADeviceListResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public getmeasure (accessToken: string, deviceId: string, scale: string, type: Array<string>, moduleId?: string, dateBegin?: number, dateEnd?: number, limit?: number, optimize?: boolean, realTime?: boolean) : Promise<{ response: http.ClientResponse; body: NAMeasureResponse;  }> {
        var path = this.url + this.basePath + '/api/getmeasure';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling getmeasure');
        }

        // verify required parameter 'deviceId' is set
        if (!deviceId) {
            throw new Error('Missing required parameter deviceId when calling getmeasure');
        }

        // verify required parameter 'scale' is set
        if (!scale) {
            throw new Error('Missing required parameter scale when calling getmeasure');
        }

        // verify required parameter 'type' is set
        if (!type) {
            throw new Error('Missing required parameter type when calling getmeasure');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (moduleId !== undefined) {
            queryParameters['module_id'] = moduleId;
        }

        if (scale !== undefined) {
            queryParameters['scale'] = scale;
        }

        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        if (dateBegin !== undefined) {
            queryParameters['date_begin'] = dateBegin;
        }

        if (dateEnd !== undefined) {
            queryParameters['date_end'] = dateEnd;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (optimize !== undefined) {
            queryParameters['optimize'] = optimize;
        }

        if (realTime !== undefined) {
            queryParameters['real_time'] = realTime;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NAMeasureResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public getthermstate (accessToken: string, deviceId: string, moduleId: string) : Promise<{ response: http.ClientResponse; body: NAThermStateResponse;  }> {
        var path = this.url + this.basePath + '/api/getthermstate';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling getthermstate');
        }

        // verify required parameter 'deviceId' is set
        if (!deviceId) {
            throw new Error('Missing required parameter deviceId when calling getthermstate');
        }

        // verify required parameter 'moduleId' is set
        if (!moduleId) {
            throw new Error('Missing required parameter moduleId when calling getthermstate');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (deviceId !== undefined) {
            queryParameters['device_id'] = deviceId;
        }

        if (moduleId !== undefined) {
            queryParameters['module_id'] = moduleId;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NAThermStateResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public partnerdevices (accessToken: string) : Promise<{ response: http.ClientResponse; body: NAPartnerDevicesResponse;  }> {
        var path = this.url + this.basePath + '/api/partnerdevices';

        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = {};


        // verify required parameter 'accessToken' is set
        if (!accessToken) {
            throw new Error('Missing required parameter accessToken when calling partnerdevices');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        var useFormData = false;

        var deferred = promise.defer<{ response: http.ClientResponse; body: NAPartnerDevicesResponse;  }>();

        var requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
