#
# Copyright 2015 SmartBear Software
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# NOTE: This class is auto generated by the swagger code generator program. 
# Do not edit the class manually.
#
package WWW::SwaggerClient::ThermostatApi;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::SwaggerClient::ApiClient;
use WWW::SwaggerClient::Configuration;

sub new {
    my $class   = shift;
    my $default_api_client = $WWW::SwaggerClient::Configuration::api_client ? $WWW::SwaggerClient::Configuration::api_client  : WWW::SwaggerClient::ApiClient->new;
    my (%self) = (
        'api_client' => $default_api_client,
        @_
    );

    #my $self = {
    #    #api_client => $options->{api_client}
    #    api_client => $default_api_client
    #}; 

    bless \%self, $class;

}

#
# createnewschedule
#
# 
# 
# @param string $access_token Your access token (required)
# @param string $device_id The relay id (required)
# @param string $module_id The thermostat id (required)
# @param NAThermProgram $therm_program The thermostat program (zones and timetable) (required)
# @return NANewScheduleResponse
#
sub createnewschedule {
    my ($self, %args) = @_;

    
    # verify the required parameter 'access_token' is set
    unless (exists $args{'access_token'}) {
      croak("Missing the required parameter 'access_token' when calling createnewschedule");
    }
    
    # verify the required parameter 'device_id' is set
    unless (exists $args{'device_id'}) {
      croak("Missing the required parameter 'device_id' when calling createnewschedule");
    }
    
    # verify the required parameter 'module_id' is set
    unless (exists $args{'module_id'}) {
      croak("Missing the required parameter 'module_id' when calling createnewschedule");
    }
    
    # verify the required parameter 'therm_program' is set
    unless (exists $args{'therm_program'}) {
      croak("Missing the required parameter 'therm_program' when calling createnewschedule");
    }
    

    # parse inputs
    my $_resource_path = '/api/createnewschedule';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'access_token'}) {
        $query_params->{'access_token'} = $self->{api_client}->to_query_value($args{'access_token'});
    }# query params
    if ( exists $args{'device_id'}) {
        $query_params->{'device_id'} = $self->{api_client}->to_query_value($args{'device_id'});
    }# query params
    if ( exists $args{'module_id'}) {
        $query_params->{'module_id'} = $self->{api_client}->to_query_value($args{'module_id'});
    }
    
    
    
    my $_body_data;
    # body params
    if ( exists $args{'therm_program'}) {
        $_body_data = $args{'therm_program'};
    }

    # authentication setting, if any
    my $auth_settings = [];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('NANewScheduleResponse', $response);
    return $_response_object;
    
}
#
# devicelist
#
# 
# 
# @param string $access_token Your access token (required)
# @param string $app_type Defines which device type will be returned by devicelist. It could be app_thermostat or app_station (by default if not provided) (optional)
# @param string $device_id Specify a device_id if you want to retrieve only this device informations. (optional)
# @param boolean $get_favorites When set to \&quot;true\&quot;, the favorite devices of the user are returned. This flag is available only if the devices requested are Weather Stations. (optional)
# @return NADeviceListResponse
#
sub devicelist {
    my ($self, %args) = @_;

    
    # verify the required parameter 'access_token' is set
    unless (exists $args{'access_token'}) {
      croak("Missing the required parameter 'access_token' when calling devicelist");
    }
    

    # parse inputs
    my $_resource_path = '/api/devicelist';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'access_token'}) {
        $query_params->{'access_token'} = $self->{api_client}->to_query_value($args{'access_token'});
    }# query params
    if ( exists $args{'app_type'}) {
        $query_params->{'app_type'} = $self->{api_client}->to_query_value($args{'app_type'});
    }# query params
    if ( exists $args{'device_id'}) {
        $query_params->{'device_id'} = $self->{api_client}->to_query_value($args{'device_id'});
    }# query params
    if ( exists $args{'get_favorites'}) {
        $query_params->{'get_favorites'} = $self->{api_client}->to_query_value($args{'get_favorites'});
    }
    
    
    
    my $_body_data;
    

    # authentication setting, if any
    my $auth_settings = [];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('NADeviceListResponse', $response);
    return $_response_object;
    
}
#
# getmeasure
#
# 
# 
# @param string $access_token Your access token (required)
# @param string $device_id Id of the device whose module&#39;s measurements you want to retrieve. This _id can be found in the user&#39;s devices field. (required)
# @param string $scale Defines the time interval between two measurements.\nPossible values :\nmax -&gt; every value stored will be returned\n30min -&gt; 1 value every 30 minutes\n1hour -&gt; 1 value every hour\n3hours -&gt; 1 value every 3 hours\n1day -&gt; 1 value per day\n1week -&gt; 1 value per week\n1month -&gt; 1 value per month (required)
# @param ARRAY[string] $type Sets the type of measurement you want to retrieve.\nThe different types of measurements must be given in a comma separated list of strings.\nExample: type=\&quot;Temperature,Humidity\&quot;\nDepending on the device&#39;s type and the scale, different measurements are available:\nFor Weather Station :\n\n  max -&gt; Temperature, CO2, Humidity, Pressure, Noise, Rain (if\nmodule_id is a rain sensor)\n\n  30min, 1hour, 3hours -&gt; Temperature, CO2, Humidity, Pressure,\nNoise, min_temp, max_temp, min_hum, max_hum, min_pressure, max_pressure, min_noise, max_noise, sum_rain (if module_id is a rain sensor)\n\n  1day, 1week, 1month -&gt; Temperature, Co2, Humidity, Pressure, Noise,\nmin_temp, date_min_temp, max_temp, date_max_temp, min_hum, date_min_hum, max_hum, date_max_hum, min_pressure, date_min_pressure, max_pressure, date_max_pressure, min_noise, date_min_noise, max_noise, date_max_noise, date_min_co2, date_max_co2, sum_rain (if module_id is a rain sensor)\nPlease note, the measurements sent in the response will be in the same order as in this list.\nAll measurements are expressed in metric units:\n\n  Temperature: Celsius\n\n  Humidity: %\n\n  Co2: ppm\n\n  Pressure: mbar\n\n  Noise: db\n\n  Rain: mm\n\nFor Thermostat:\n\n  max -&gt; Temperature, Sp_Temperature, BoilerOn, BoilerOff\n\n  30min, 1hour, 3hours -&gt; Temperature, Sp_Temperature, min_temp,\nmax_temp, sum_boiler_on, sum_boiler_off\n\n  1day, 1week, 1month -&gt; Temperature, min_temp, date_min_temp,\nmax_temp, sum_boiler_on, sum_boiler_off\n\n  where\n\nTemperature: Celsius\n\n  Sp_Temperature (temperature setpoint): Celsius\n\n  BoilerOn: Duration, since the previous data point, during which the\nboiler has been on (in seconds)\n\n  BoilerOff : Duration, since the previous data point, during which\nthe boiler has been off (in seconds).\n\n  sum_boiler_on: Total duration during which the boiler has been on,\nat a specific scale (in seconds).\n\n  sum_boiler_off: Total duration during which the boiler has been\noff, at a specific scale (in seconds). (required)
# @param string $module_id If you don&#39;t specify any module_id you will retrieve the device&#39;s measurements. If you specify a module_id you will retrieve the module&#39;s measurements. (optional)
# @param int $date_begin Starting timestamp (utc) of the requested measurements.\nPlease note measurement retrieving is limited to 1024 measurements. (optional)
# @param int $date_end Ending timestamp (utc) of the request measurements.\nIf you want only the last measurement, do not provide date_begin, and set date_end to \&quot;last\&quot;. (optional)
# @param int $limit Limits the number of measurements returned (default &amp; max is 1024) (optional)
# @param boolean $optimize Allows you to choose the format of the answer.\nIf you build a mobile app and bandwith usage is an issue, use optimize = true.\nUse optimize = false, for an easier parse. In this case, values are indexed by sorted timestamp.\nExample of un-optimized response :\n{\&quot;status\&quot;: \&quot;ok\&quot;, \n  \&quot;body\&quot;: {\n    \&quot;1347575400\&quot;: [18.3,39],\n    \&quot;1347586200\&quot;: [20.6,48]\n  },\n\&quot;time_exec\&quot;: 0.012136936187744}\nIf optimize is set true, measurements are returned as an array of series of regularly spaced measurements. Each series is defined by a beginning time beg_time and a step between measurements, step_time:\n{\&quot;status\&quot;: \&quot;ok\&quot;,\n  \&quot;body\&quot;: [\n    {\&quot;beg_time\&quot;: 1347575400,\n     \&quot;step_time\&quot;: 10800,\n     \&quot;value\&quot;: \n        [[18.3,39],\n        [ 20.6,48]]\n    }],\n\&quot;time_exec\&quot;: 0.014238119125366}\nDefault value is true. (optional)
# @param boolean $real_time In scales higher than max, since the data is aggregated, the timestamps returned are by default offset by +(scale/2).\nFor instance, if you ask for measurements at a daily scale, you will receive data timestamped at 12:00 if real_time is set to false (default case), and timestamped at 00:00 if real_time is set to true.\nNB : The servers always store data with real_time set to true and data are offset by this parameter AFTER having being time-filtered, thus you could have data after date_end if real_time is set to false. (optional)
# @return NAMeasureResponse
#
sub getmeasure {
    my ($self, %args) = @_;

    
    # verify the required parameter 'access_token' is set
    unless (exists $args{'access_token'}) {
      croak("Missing the required parameter 'access_token' when calling getmeasure");
    }
    
    # verify the required parameter 'device_id' is set
    unless (exists $args{'device_id'}) {
      croak("Missing the required parameter 'device_id' when calling getmeasure");
    }
    
    # verify the required parameter 'scale' is set
    unless (exists $args{'scale'}) {
      croak("Missing the required parameter 'scale' when calling getmeasure");
    }
    
    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling getmeasure");
    }
    

    # parse inputs
    my $_resource_path = '/api/getmeasure';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'access_token'}) {
        $query_params->{'access_token'} = $self->{api_client}->to_query_value($args{'access_token'});
    }# query params
    if ( exists $args{'device_id'}) {
        $query_params->{'device_id'} = $self->{api_client}->to_query_value($args{'device_id'});
    }# query params
    if ( exists $args{'module_id'}) {
        $query_params->{'module_id'} = $self->{api_client}->to_query_value($args{'module_id'});
    }# query params
    if ( exists $args{'scale'}) {
        $query_params->{'scale'} = $self->{api_client}->to_query_value($args{'scale'});
    }# query params
    if ( exists $args{'type'}) {
        $query_params->{'type'} = $self->{api_client}->to_query_value($args{'type'});
    }# query params
    if ( exists $args{'date_begin'}) {
        $query_params->{'date_begin'} = $self->{api_client}->to_query_value($args{'date_begin'});
    }# query params
    if ( exists $args{'date_end'}) {
        $query_params->{'date_end'} = $self->{api_client}->to_query_value($args{'date_end'});
    }# query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }# query params
    if ( exists $args{'optimize'}) {
        $query_params->{'optimize'} = $self->{api_client}->to_query_value($args{'optimize'});
    }# query params
    if ( exists $args{'real_time'}) {
        $query_params->{'real_time'} = $self->{api_client}->to_query_value($args{'real_time'});
    }
    
    
    
    my $_body_data;
    

    # authentication setting, if any
    my $auth_settings = [];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('NAMeasureResponse', $response);
    return $_response_object;
    
}
#
# getthermstate
#
# 
# 
# @param string $access_token Your access token (required)
# @param string $device_id The relay id (required)
# @param string $module_id The thermostat id (required)
# @return NAThermStateResponse
#
sub getthermstate {
    my ($self, %args) = @_;

    
    # verify the required parameter 'access_token' is set
    unless (exists $args{'access_token'}) {
      croak("Missing the required parameter 'access_token' when calling getthermstate");
    }
    
    # verify the required parameter 'device_id' is set
    unless (exists $args{'device_id'}) {
      croak("Missing the required parameter 'device_id' when calling getthermstate");
    }
    
    # verify the required parameter 'module_id' is set
    unless (exists $args{'module_id'}) {
      croak("Missing the required parameter 'module_id' when calling getthermstate");
    }
    

    # parse inputs
    my $_resource_path = '/api/getthermstate';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'access_token'}) {
        $query_params->{'access_token'} = $self->{api_client}->to_query_value($args{'access_token'});
    }# query params
    if ( exists $args{'device_id'}) {
        $query_params->{'device_id'} = $self->{api_client}->to_query_value($args{'device_id'});
    }# query params
    if ( exists $args{'module_id'}) {
        $query_params->{'module_id'} = $self->{api_client}->to_query_value($args{'module_id'});
    }
    
    
    
    my $_body_data;
    

    # authentication setting, if any
    my $auth_settings = [];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('NAThermStateResponse', $response);
    return $_response_object;
    
}
#
# getuser
#
# 
# 
# @param string $access_token Your access token (required)
# @return NAUserResponse
#
sub getuser {
    my ($self, %args) = @_;

    
    # verify the required parameter 'access_token' is set
    unless (exists $args{'access_token'}) {
      croak("Missing the required parameter 'access_token' when calling getuser");
    }
    

    # parse inputs
    my $_resource_path = '/api/getuser';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'access_token'}) {
        $query_params->{'access_token'} = $self->{api_client}->to_query_value($args{'access_token'});
    }
    
    
    
    my $_body_data;
    

    # authentication setting, if any
    my $auth_settings = [];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('NAUserResponse', $response);
    return $_response_object;
    
}
#
# setthermpoint
#
# 
# 
# @param string $access_token Your access token (required)
# @param string $device_id The relay id (required)
# @param string $module_id The thermostat id (required)
# @param string $setpoint_mode Chosen setpoint_mode (required)
# @param int $setpoint_endtime When using the manual or max setpoint_mode, this parameter defines when the setpoint expires. (optional)
# @param double $setpoint_temp When using the manual setpoint_mode, this parameter defines the temperature setpoint (in Celcius) to use. (optional)
# @return NAOkResponse
#
sub setthermpoint {
    my ($self, %args) = @_;

    
    # verify the required parameter 'access_token' is set
    unless (exists $args{'access_token'}) {
      croak("Missing the required parameter 'access_token' when calling setthermpoint");
    }
    
    # verify the required parameter 'device_id' is set
    unless (exists $args{'device_id'}) {
      croak("Missing the required parameter 'device_id' when calling setthermpoint");
    }
    
    # verify the required parameter 'module_id' is set
    unless (exists $args{'module_id'}) {
      croak("Missing the required parameter 'module_id' when calling setthermpoint");
    }
    
    # verify the required parameter 'setpoint_mode' is set
    unless (exists $args{'setpoint_mode'}) {
      croak("Missing the required parameter 'setpoint_mode' when calling setthermpoint");
    }
    

    # parse inputs
    my $_resource_path = '/api/setthermpoint';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'access_token'}) {
        $query_params->{'access_token'} = $self->{api_client}->to_query_value($args{'access_token'});
    }# query params
    if ( exists $args{'device_id'}) {
        $query_params->{'device_id'} = $self->{api_client}->to_query_value($args{'device_id'});
    }# query params
    if ( exists $args{'module_id'}) {
        $query_params->{'module_id'} = $self->{api_client}->to_query_value($args{'module_id'});
    }# query params
    if ( exists $args{'setpoint_mode'}) {
        $query_params->{'setpoint_mode'} = $self->{api_client}->to_query_value($args{'setpoint_mode'});
    }# query params
    if ( exists $args{'setpoint_endtime'}) {
        $query_params->{'setpoint_endtime'} = $self->{api_client}->to_query_value($args{'setpoint_endtime'});
    }# query params
    if ( exists $args{'setpoint_temp'}) {
        $query_params->{'setpoint_temp'} = $self->{api_client}->to_query_value($args{'setpoint_temp'});
    }
    
    
    
    my $_body_data;
    

    # authentication setting, if any
    my $auth_settings = [];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('NAOkResponse', $response);
    return $_response_object;
    
}
#
# switchschedule
#
# 
# 
# @param string $access_token Your access token (required)
# @param string $device_id The relay id (required)
# @param string $module_id The thermostat id (required)
# @param string $schedule_id The schedule id. It can be found in the getthermstate response, under the keys \&quot;therm_program_backup\&quot; and \&quot;therm_program\&quot;. (required)
# @return NAOkResponse
#
sub switchschedule {
    my ($self, %args) = @_;

    
    # verify the required parameter 'access_token' is set
    unless (exists $args{'access_token'}) {
      croak("Missing the required parameter 'access_token' when calling switchschedule");
    }
    
    # verify the required parameter 'device_id' is set
    unless (exists $args{'device_id'}) {
      croak("Missing the required parameter 'device_id' when calling switchschedule");
    }
    
    # verify the required parameter 'module_id' is set
    unless (exists $args{'module_id'}) {
      croak("Missing the required parameter 'module_id' when calling switchschedule");
    }
    
    # verify the required parameter 'schedule_id' is set
    unless (exists $args{'schedule_id'}) {
      croak("Missing the required parameter 'schedule_id' when calling switchschedule");
    }
    

    # parse inputs
    my $_resource_path = '/api/switchschedule';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'access_token'}) {
        $query_params->{'access_token'} = $self->{api_client}->to_query_value($args{'access_token'});
    }# query params
    if ( exists $args{'device_id'}) {
        $query_params->{'device_id'} = $self->{api_client}->to_query_value($args{'device_id'});
    }# query params
    if ( exists $args{'module_id'}) {
        $query_params->{'module_id'} = $self->{api_client}->to_query_value($args{'module_id'});
    }# query params
    if ( exists $args{'schedule_id'}) {
        $query_params->{'schedule_id'} = $self->{api_client}->to_query_value($args{'schedule_id'});
    }
    
    
    
    my $_body_data;
    

    # authentication setting, if any
    my $auth_settings = [];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('NAOkResponse', $response);
    return $_response_object;
    
}
#
# syncschedule
#
# 
# 
# @param string $access_token Your access token (required)
# @param string $device_id The relay id (required)
# @param string $module_id The thermostat id (required)
# @param NAThermProgram $therm_program The thermostat program (zones, timetable and name) (required)
# @return NAOkResponse
#
sub syncschedule {
    my ($self, %args) = @_;

    
    # verify the required parameter 'access_token' is set
    unless (exists $args{'access_token'}) {
      croak("Missing the required parameter 'access_token' when calling syncschedule");
    }
    
    # verify the required parameter 'device_id' is set
    unless (exists $args{'device_id'}) {
      croak("Missing the required parameter 'device_id' when calling syncschedule");
    }
    
    # verify the required parameter 'module_id' is set
    unless (exists $args{'module_id'}) {
      croak("Missing the required parameter 'module_id' when calling syncschedule");
    }
    
    # verify the required parameter 'therm_program' is set
    unless (exists $args{'therm_program'}) {
      croak("Missing the required parameter 'therm_program' when calling syncschedule");
    }
    

    # parse inputs
    my $_resource_path = '/api/syncschedule';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'access_token'}) {
        $query_params->{'access_token'} = $self->{api_client}->to_query_value($args{'access_token'});
    }# query params
    if ( exists $args{'device_id'}) {
        $query_params->{'device_id'} = $self->{api_client}->to_query_value($args{'device_id'});
    }# query params
    if ( exists $args{'module_id'}) {
        $query_params->{'module_id'} = $self->{api_client}->to_query_value($args{'module_id'});
    }
    
    
    
    my $_body_data;
    # body params
    if ( exists $args{'therm_program'}) {
        $_body_data = $args{'therm_program'};
    }

    # authentication setting, if any
    my $auth_settings = [];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('NAOkResponse', $response);
    return $_response_object;
    
}


1;
