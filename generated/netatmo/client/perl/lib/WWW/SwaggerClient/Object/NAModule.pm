package WWW::SwaggerClient::Object::NAModule;

require 5.6.0;
use strict;
use warnings;
use utf8;
use JSON qw(decode_json);
use Data::Dumper;
use Module::Runtime qw(use_module);
use Log::Any qw($log);
use Date::Parse;
use DateTime;

use base "WWW::SwaggerClient::Object::BaseObject";

#
#
#
#NOTE: This class is auto generated by the swagger code generator program. Do not edit the class manually.
#

my $swagger_types = {
    '_id' => 'string',
    'date_setup' => 'NADate',
    'firmware' => 'int',
    'type' => 'string',
    'module_name' => 'string',
    'main_device' => 'string',
    'last_message' => 'int',
    'last_seen' => 'int',
    'public_ext_data' => 'boolean',
    'rf_status' => 'int',
    'battery_vp' => 'int',
    'therm_orientation' => 'int',
    'therm_relay_cmd' => 'int',
    'dashboard_data' => 'NADashboardData',
    'data_type' => 'ARRAY[string]'
};

my $attribute_map = {
    '_id' => '_id',
    'date_setup' => 'date_setup',
    'firmware' => 'firmware',
    'type' => 'type',
    'module_name' => 'module_name',
    'main_device' => 'main_device',
    'last_message' => 'last_message',
    'last_seen' => 'last_seen',
    'public_ext_data' => 'public_ext_data',
    'rf_status' => 'rf_status',
    'battery_vp' => 'battery_vp',
    'therm_orientation' => 'therm_orientation',
    'therm_relay_cmd' => 'therm_relay_cmd',
    'dashboard_data' => 'dashboard_data',
    'data_type' => 'data_type'
};

# new object
sub new { 
    my ($class, %args) = @_; 
    my $self = { 
        #
        '_id' => $args{'_id'}, 
        #
        'date_setup' => $args{'date_setup'}, 
        #
        'firmware' => $args{'firmware'}, 
        #Included in every device or module. It defines the type of the device/module. Its values are among :\nNAMain : for the base station\nNAModule1 : for the outdoor module\nNAModule4 : for the additionnal indoor module\nNAModule3 : for the rain gauge module\nNAPlug : for the thermostat relay/plug\nNATherm1 : for the thermostat module
        'type' => $args{'type'}, 
        #
        'module_name' => $args{'module_name'}, 
        #
        'main_device' => $args{'main_device'}, 
        #
        'last_message' => $args{'last_message'}, 
        #
        'last_seen' => $args{'last_seen'}, 
        #
        'public_ext_data' => $args{'public_ext_data'}, 
        #\"It contains the current radio status. The different thresholds to take into account are :\" |\nRADIO_THRESHOLD_SIGNAL_LOW = 90 \nRADIO_THRESHOLD_SIGNAL_MEDIUM = 80\nRADIO_THRESHOLD_SIGNAL_HIGH = 70\nRADIO_THRESHOLD_SIGNAL_FULL = 60
        'rf_status' => $args{'rf_status'}, 
        #It contains the current battery status. The threshold depends on the kind of module, below is the list of the different threshold to take into account according the module type.\n\"Indoor module Battery range: 6000 ... 4200\" |\nINDOOR_BATTERY_LEVEL_FULL = 5640\nINDOOR_BATTERY_LEVEL_HIGH = 5280\nINDOOR_BATTERY_LEVEL_MEDIUM = 4920\nINDOOR_BATTERY_LEVEL_LOW = 4560\n\"Below 4560: very low\" |\n  \n\"Raingauge and outdoor module Battery range: 6000 ... 3600\" |\nBATTERY_LEVEL_FULL = 5500\nBATTERY_LEVEL_HIGH = 5000\nBATTERY_LEVEL_MEDIUM = 4500\nBATTERY_LEVEL_LOW = 4000\n\"Below 4000: very low\" |\n  \n\"Thermostat Battery range: 4500 ... 3000\" |\nTHERMOSTAT_BATTERY_LEVEL_FULL = 4100\nTHERMOSTAT_BATTERY_LEVEL_HIGH = 3600\nTHERMOSTAT_BATTERY_LEVEL_MEDIUM = 3300\nTHERMOSTAT_BATTERY_LEVEL_LOW = 3000\n\"Below 3000: very low\"
        'battery_vp' => $args{'battery_vp'}, 
        #
        'therm_orientation' => $args{'therm_orientation'}, 
        #
        'therm_relay_cmd' => $args{'therm_relay_cmd'}, 
        #It contains all the measurements that can be displayed on the dashboard
        'dashboard_data' => $args{'dashboard_data'}, 
        #
        'data_type' => $args{'data_type'}
    }; 

    return bless $self, $class; 
}  

# get swagger type of the attribute
sub get_swagger_types {
    return $swagger_types;
}

# get attribute mappping
sub get_attribute_map {
    return $attribute_map;
}

1;
